name: Build and Release

on:
    push:
        branches:
            - main
        paths:
            - "tools/imports/**"

    # Manual trigger
    workflow_dispatch:

permissions:
    contents: write # Allow the action to write to the repository (for creating tags/releases)
    discussions: read # Optional, adjust according to your needs

jobs:
    build:
        runs-on: ubuntu-latest

        concurrency:
            group: build-and-release-${{ github.ref }}
            cancel-in-progress: true

        steps:
            # Step 1: Add a delay (sleep for 15 minutes = 900 seconds), only for push events
            - name: Wait for 15 minutes (only on push)
              if: github.event_name == 'push'
              run: sleep 900

            # Step 2: Checkout the code
            - name: Checkout code
              uses: actions/checkout@v3
              with:
                  fetch-depth: 0 # Fetch all history for changelog generation

            # Step 3: Install GitHub CLI (gh)
            - name: Install GitHub CLI
              run: sudo apt-get install gh -y

            # Step 4: Set Version from Git Tags
            - name: Set Version from Git Tags
              id: set_version
              run: |
                  # Fetch all tags to ensure we have the latest version information
                  git fetch --tags
                  
                  # Use date-based versioning: 2025.08.20.X format
                  DATE_VERSION=$(date +%Y.%m.%d)
                  
                  # Check if a tag with today's date already exists
                  EXISTING_TAGS=$(git tag -l "v${DATE_VERSION}.*" | sort -V)
                  
                  if [ -z "$EXISTING_TAGS" ]; then
                    # No tags for today, start with .1
                    BUILD_NUMBER="1"
                  else
                    # Get the highest build number for today and increment
                    LATEST_BUILD=$(echo "$EXISTING_TAGS" | tail -1 | sed "s/v${DATE_VERSION}.//" )
                    BUILD_NUMBER=$((LATEST_BUILD + 1))
                  fi
                  
                  NEW_VERSION="${DATE_VERSION}.${BUILD_NUMBER}"
                  
                  echo "TAG=v$NEW_VERSION" >> $GITHUB_ENV
                  echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
                  echo "ZIP_NAME=QuaziiUI-v$NEW_VERSION.zip" >> $GITHUB_ENV
                  echo "Existing tags for today: $EXISTING_TAGS"
                  echo "New version will be: v$NEW_VERSION"
            
            # Step 5: Modify QuaziiUI/init.lua if DEBUG_MODE is true
            - name: Check and update QuaziiUI.DEBUG_MODE in init.lua
              run: |
                  INIT_FILE="./QuaziiUI/init.lua"
                  
                  if grep -q "QuaziiUI.DEBUG_MODE = true" "$INIT_FILE"; then
                      echo "Debug: DEBUG_MODE is set to true. Updating to false."
                      sed -i 's/QuaziiUI.DEBUG_MODE = true/QuaziiUI.DEBUG_MODE = false/' "$INIT_FILE"
                  else
                      echo "Debug: DEBUG_MODE is already false or not found."
                  fi

            # Step 6: Ensure the version matches the release tag in QuaziiUI.toc
            - name: Update version in QuaziiUI.toc
              run: |
                  TOC_FILE="./QuaziiUI/QuaziiUI.toc"
                  echo "Debug: Updating .toc version to ${{ env.NEW_VERSION }}."
                  sed -i "s/@project-version@/${{ env.NEW_VERSION }}/g" "$TOC_FILE"

            # Step 7: Run build.py
            - name: Run build.py
              run: python tools/build.py

            # Step 8: Zip the QuaziiUI directory
            - name: Zip QuaziiUI directory
              run: |
                  echo "Debug: Zipping QuaziiUI directory to ${{ env.ZIP_NAME }}"
                  zip -r ${{ env.ZIP_NAME }} QuaziiUI

            # Step 9: Generate changelog
            - name: Generate changelog
              run: |
                  # Get the latest tag name across all branches
                  LAST_TAG=$(git describe --tags $(git rev-list --tags --max-count=1) 2>/dev/null)
                  
                  # Check if there are any tags
                  if [ -n "$LAST_TAG" ]; then
                      echo "Debug: Last tag found: $LAST_TAG"
                      echo "Changes since $LAST_TAG:" > CHANGELOG.md
                      git log $LAST_TAG..HEAD --oneline >> CHANGELOG.md
                  else
                      # If no tags exist, generate changelog for all commits
                      echo "Debug: No tags found, generating changelog for all commits."
                      echo "Changes since the beginning:" > CHANGELOG.md
                      git log --oneline >> CHANGELOG.md
                  fi

            - name: Output changelog
              id: changelog
              run: |
                  echo "Debug: Generated changelog content"
                  cat CHANGELOG.md

            # Step 10: Create GitHub Release
            - name: Create GitHub Release
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  echo "Debug: Creating release for tag ${{ env.TAG }}"
                  
                  # Check if release already exists
                  if gh release view ${{ env.TAG }} >/dev/null 2>&1; then
                    echo "Release ${{ env.TAG }} already exists. Deleting and recreating..."
                    gh release delete ${{ env.TAG }} --yes
                    # Also delete the tag if it exists
                    git tag -d ${{ env.TAG }} 2>/dev/null || true
                    git push origin --delete ${{ env.TAG }} 2>/dev/null || true
                  fi
                  
                  # Create the release
                  gh release create ${{ env.TAG }} \
                    ${{ env.ZIP_NAME }} \
                    --title "QuaziiUI ${{ env.TAG }}" \
                    --notes-file CHANGELOG.md \
                    --target main
